import cv2
import cv2.aruco as aruco
import numpy as np
from gpiozero import AngularServo
from time import sleep
from gpiozero.pins.pigpio import PiGPIOFactory

print("Starting")

# Initialize USB camera (Arducam 1080P)
def initialize_camera():
    vid = cv2.VideoCapture(0)  # Assuming the USB camera is recognized as device 0
    if not vid.isOpened():
        print("Failed to open camera")
        return None
    print("Camera initialized")
    return vid

def findArucoMarkers(img, markerSize=4, totalMarkers=250, draw=True):
    arucoDict = aruco.Dictionary_get(aruco.DICT_ARUCO_ORIGINAL)
    arucoParam = aruco.DetectorParameters_create()
    bbox, ids, rejected = aruco.detectMarkers(img, arucoDict, parameters=arucoParam)
    
    if draw:
        aruco.drawDetectedMarkers(img, bbox)
    return bbox, ids, rejected

class ArucoMarker():
    def __init__(self):
        self.bboxtl = None
        self.bboxbr = None
        self.centre = None
    
    @staticmethod
    def getCentre(bboxtl, bboxbr):
        return int((bboxtl[0] + bboxbr[0]) / 2), int((bboxtl[1] + bboxbr[1]) / 2)

def getArucos(img):
    img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    arucos = []
    bboxs, ids, rejected = findArucoMarkers(img, markerSize=4, totalMarkers=250, draw=True)
    
    if np.any(ids is None):
        return [], 0
    else:
        for bbox in bboxs:
            aruco = ArucoMarker()
            aruco.bboxtl = bbox[0][0][0], bbox[0][0][1]
            aruco.bboxbr = bbox[0][2][0], bbox[0][2][1]
            aruco.centre = ArucoMarker.getCentre(aruco.bboxtl, aruco.bboxbr)
            arucos.append(aruco)
        return arucos, 1

def getAdjustment(windowMax, x):
    normalised_adjustment = x / windowMax - 0.5
    adjustment_magnitude = abs(round(normalised_adjustment, 1))
    adjustment_direction = -1 if normalised_adjustment > 0 else 1
    return adjustment_magnitude, adjustment_direction

# Function to resize frame (used for performance)
def rescale_frame(frame, percent):
    width = int(frame.shape[1] * percent / 100)
    height = int(frame.shape[0] * percent / 100)
    dim = (width, height)
    return cv2.resize(frame, dim, interpolation=cv2.INTER_AREA)

# Initialize camera
vid = initialize_camera()
if vid is None:
    exit()  # Exit if camera failed to initialize

# Initialize servos on GPIO pins 18 and 13 (swapped)
pigpio_factory = PiGPIOFactory()
servo1 = AngularServo(13, pin_factory=pigpio_factory)  # Servo 1 now on Pin 13
servo2 = AngularServo(18, pin_factory=pigpio_factory)  # Servo 2 now on Pin 18

servo1_now = 0
servo2_now = 0
servo1.angle = servo1_now
servo2.angle = servo2_now
sleep(2)
print("Initialized servos (Servo 1 on GPIO 13 and Servo 2 on GPIO 18).")

# Constants
cx = -1  # Adjust if servo direction is reversed
cy = 1
Kp = 80
Kd = 10

xmag_old = 0
ymag_old = 0

# Main loop
while True:
    # Capture frame-by-frame
    ret, img = vid.read()
    if not ret:
        print("Failed to grab frame")
        break
    
    # Rescale frame to improve performance
    img = rescale_frame(img, 50)
    window = img.shape
    
    # Get ArUco markers
    arucos, ret = getArucos(img)
    if ret == 0:
        continue  # Skip if no marker found
    
    # Get marker center for adjustment
    B = arucos[0].centre

    # Get adjustment magnitudes for X and Y axes
    xmag, xdir = getAdjustment(window[0], B[1])
    ymag, ydir = getAdjustment(window[1], B[0])

    if xmag is not None:
        # Proportional adjustments
        adj_Kpx = cx * Kp * xdir * xmag
        adj_Kpy = cy * Kp * ydir * ymag
        
        # Derivative adjustments
        adj_Kdx = cx * Kd * xdir * (xmag - xmag_old)
        adj_Kdy = cy * Kd * ydir * (ymag - ymag_old)
        
        # Total adjustments
        adjustment_x = adj_Kpx + adj_Kdx
        adjustment_y = adj_Kpy + adj_Kdy
        
        # Update servo angles
        servo1_now += adjustment_x
        servo2_now += adjustment_y
        
        # Reset if angles exceed bounds
        if abs(servo1_now) > 90:
            servo1_now = 0
        if abs(servo2_now) > 90:
            servo2_now = 0
        
        servo1.angle = servo1_now
        servo2.angle = servo2_now
        
        # Small delay for smooth movement
        sleep(0.01)
        
        # Store old values for derivative control
        xmag_old = xmag
        ymag_old = ymag
    
    # Display the resulting frame
    cv2.imshow('Camera Feed', img)
    
    # Break the loop on 'q' key press
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release the camera and close all OpenCV windows
vid.release()
cv2.destroyAllWindows()
