import cv2
import cv2.aruco as aruco
import numpy as np
from gpiozero import AngularServo
from time import sleep, time
from gpiozero.pins.pigpio import PiGPIOFactory
import threading

# Initialize camera and PiGPIO for servos
vid = cv2.VideoCapture(0)
vid.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
vid.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
print("Video started")

pigpio_factory = PiGPIOFactory()
servo1 = AngularServo(18, pin_factory=pigpio_factory, min_angle=-90, max_angle=90)
servo2 = AngularServo(13, pin_factory=pigpio_factory, min_angle=-90, max_angle=90)

# Servo initial positions
servo1.angle, servo2.angle = 0, 0
sleep(2)
print("Servos initialized.")

# Constants
Kp = 80
Kd = 10
cx, cy = -1, 1  # Invert directions as needed

def findArucoMarkers(img, marker_size=7):
    aruco_dict = aruco.Dictionary_get(aruco.DICT_7X7_50)
    aruco_params = aruco.DetectorParameters_create()
    bbox, ids, _ = aruco.detectMarkers(img, aruco_dict, parameters=aruco_params)
    if len(bbox) > 0:
        aruco.drawDetectedMarkers(img, bbox)
    return bbox, ids

def getCentre(bboxtl, bboxbr):
    return (int((bboxtl[0] + bboxbr[0]) / 2), int((bboxtl[1] + bboxbr[1]) / 2))

def getArucos(img):
    bboxs, ids = findArucoMarkers(img)
    if ids is not None:
        centres = [getCentre(bbox[0][0], bbox[0][2]) for bbox in bboxs]
        return centres[0], True  # Only return first marker's center
    return None, False

def getAdjustment(window_max, x):
    normalized_adjustment = x / window_max - 0.5
    adjustment_direction = -1 if normalized_adjustment > 0 else 1
    return abs(round(normalized_adjustment, 1)), adjustment_direction

def process_frame():
    _, frame = vid.read()
    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    centre, found = getArucos(frame)
    cv2.imshow("Frame", frame)
    cv2.waitKey(1)
    return centre, found, frame.shape if found else None

# Run servo control and camera in separate threads
servo1_angle, servo2_angle = 0, 0
def control_servos():
    global servo1_angle, servo2_angle
    xmag_old, ymag_old = 0, 0

    while True:
        centre, found, window = process_frame()
        if not found:
            continue
        
        # Get adjustments based on center position
        xmag, xdir = getAdjustment(window[1], centre[0])
        ymag, ydir = getAdjustment(window[0], centre[1])

        # Proportional adjustments
        adj_Kpx = cx * Kp * xdir * xmag
        adj_Kpy = cy * Kp * ydir * ymag

        # Derivative adjustments
        adj_Kdx = cx * Kd * xdir * (xmag - xmag_old)
        adj_Kdy = cy * Kd * ydir * (ymag - ymag_old)
        
        # Update servo angles with constraints
        servo1_angle = max(min(servo1_angle + adj_Kpx + adj_Kdx, 90), -90)
        servo2_angle = max(min(servo2_angle + adj_Kpy + adj_Kdy, 90), -90)

        # Apply adjustments to servos
        servo1.angle = servo1_angle
        servo2.angle = servo2_angle

        xmag_old, ymag_old = xmag, ymag
        sleep(0.01)

# Start control loop in a new thread
servo_thread = threading.Thread(target=control_servos)
servo_thread.start()

# Main loop for cleanup and ensuring smooth thread operation
try:
    while True:
        sleep(1)
except KeyboardInterrupt:
    vid.release()
    cv2.destroyAllWindows()
    print("Stopped")
